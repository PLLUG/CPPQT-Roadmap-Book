# Тип std::vector

Якщо нам необхідно мати **список значень якогось конкретного типу** та наперед невідомо скільки цих значень ми будемо зберігати \(або ці значення необхідно одавати та видаляти зі списку у процесі роботи програми\), то можна скористатися типом `std::vector` зі стандартної бібліотеки С++.

Наприклад, нам необхідно створити програму, у яку можна ввести список студентів які входять до навчальної групи. Тоді ми можемо оголосити список студентів наступним чином:

```cpp
std::vector<std::string> vec;
```

Тут у фігурних дужках, ми зазначаємо **тип для значень, які ми  будемо зберігати у списку**. Тип задається лише раз при створенні списку та його не можна змінити. Також не можна додавати значення іншого типу до списку - список буде зберігати лише значення типу заданого під час його створення. 

Покажемо кілька способів роботи з вектором:

| Приклад коду | Пояснення |
| :---: | :--- |
| `#include <vector>` | Підключити визначення типу std::vector зі стандартної бібліотеки. |
| `std::vector<std::string> vec;` | Створюємо змінну `vec`- вектор який містить значення типу `std::string`. Замість `std::string` можна підставити інший необхідний нам тип. |
| `std::vector<char> evenDigits {2, 4, 6, 8};` | Створюємо вектор та ініціалізовуємо вектор готовим набором значень. |
| `std::vector<double> zeros(10, 0.0);` | Створюємо вектор, який матиме 10 елементів, кожен з яких містить значення `0.0` |
| `vec.push_back("str1");` | Додає новий елемент \(рядок `"str1"`\) у кінець вектора. |
| `vec.size()` | Повертає кількість елементів у векторі. Кожен елемент має індекс \(номер\) - ціле число. Елементи індексуються по порядку починаючи з `0` до `vec.size() - 1` |
| `vec.at(0)` | Повертає елемент з індексом 0. Елементи індексуються по порядку замість `0` до `vec.size() - 1` |
| `vec.clear();` | Очистити вектор, видалити всі значення. Після виконання вектор не містить жодних елементів. |
| `vec.empty()` | Повертає true якщо вектор пустий. |
| `vec.insert(1, "str3")` | Вставляє елемент всередину списку \(у позицію з індексом 1\). Очевидно, у списку стає на один елемент більше, а позиції елементів після 1 зміщуються.  |

Розберемо ці способи роботи з вектором на прикладі програми, яка очікує від користувача, що він введе список студентів, а потім виводить його у консоль по порядку. 

```cpp
#include <vector>
#include <string>
#include <iostream>

const std::string cExitValue {"exit"};

int main()
{
	std::vector<std::string> studentsList;

	std::string nextStudent;
	do
	{
		std::cin >> nextStudent;

		if (nextStudent != cExitValue)
		{
			 studentsList.push_back(nextStudent);
		}
	} 
	while(nextStudent != cExitValue);

	for (int index = 0; index < studentsList.size(); ++index)
	{
		std::cout << index << " : " << studentsList.at(index) << std::endl;
	}
}
```

У цій програмі ми створюємо вектор та наповнємо його значеннями у циклі. Кожна ітерація циклу очікує вводу імені студента, яке зберігається у змінній . Якщо замість імені студента користувач ввів слово `"exit"`, то програма виходить з циклу \(зверніть увагу: значення `"exit"` ми до списку не додаємо\). Далі ми проходимо по всіх значеннях в списку і виводимо їх у консоль \(разом з індексом\). 

{% file src="../../.gitbook/assets/vector\_demo.cpp" caption="vector\_demo.cpp" %}

