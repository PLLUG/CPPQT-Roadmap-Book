# Змінні. Деякі з основних типів та їх застосування.

## Змінні

Для того, щоб зберігати у програмі будь-яку інформацію, нам необхідно оголосити змінну \(_variable_\), яка буде її містити. Оголошення змінної складається з назви **типу** даних \(_data type_\), які будуть зберігатися у змінній та **імені змінної** \(_variable name_\), через яке ми зможемо доступатися до даних. Наприклад:

```cpp
int backyardTreeCount;
double milesToRun;
char currentLetterInVocabulary;
```

Змінній, ми можемо **присвоїти \(**_**assign**_**\) значення \(**_**value**_**\)** використавши **оператор присвоєння **`=`** \(**_**assigment operator**_**\)**. Наприклад:

```cpp
backyardTreeCount = 3;
int numberOfBenchesOnBackyard{2};
```

Як ми бачимо, ми можемо **оголошувати змінні і одразу ж присвоювати їм значення з допомогою фігурних дужок**, як у випадку з `numberOfBenchesOnBackyard`. Врешті решт, ми можемо доступитися до значення змінної через її ім'я. Наприклад, вивести у консоль її значення:

```cpp
std::cout << "My backyard:" << std::endl;
std::cout << "    number of trees: " << backyardTreeCount << std::endl;
std::cout << "    number of benches: " << numberOfBenchesOnBackyard << std::endl;
```

С++ є строго типізованою мовою, що означає: **змінна отримує тип при оголошенні і цей тип не може змінитися**. Тобто до кінця використання цієї змінної вона буде зберігати значення виключно лише цього типу.

Так, загалом ми також можемо присвоювати одній змінній значення іншої змінної за умови, що **типи співпадають**. Тим не меньш, існують вийнятки з цього правила \(один з таких вийнятків читайте нижче у параграфі _"Типи int та double. Неявне приведення типів"_\).

## Деякі важливі типи

Нижче приведена таблиця \(для зручності\) з кількома типами, корисними для того, щоб почати писати прості програми мовою С++. Далі ідуть кілька парагафів з більш детальними прикладами та особливостями використання цих типів. Автор рекомендує, ознайомитися з типами та наведеними нижче відомостями про них, проте не варто намагатися вивчити все одразу. Найкращим підходом буде - написати кілька маленьких програм та поексперементувати з ними, а потім - повертатися до цього розділу час від часу. Надалі у прикладах та завданнях ви зможете ці типи повноціно опанувати.

| Тип | Опис | Приклад | Бібліотека |
| --- | --- | --- | --- |
| `int` | Цілі позитивні та від'ємні числа. | `int backyardTreeCount {3};` | Вбудований тип. Не потребує підключення додаткових бібіліотек. |
| `double` | Числа з плаваючою комою. | `double milesToRun {2.1};` | Вбудований тип. Не потребує підключення додаткових бібіліотек. |
| `bool` | Логічний тип. Може містити значення `true` \(істина\) або `false` \(брехня\) | `bool pllugIsCool {true};` | Вбудований тип. Не потребує підключення додаткових бібіліотек. |
| `char` | Символ | `char firstLetter = 'a';` | Вбудований тип. Не потребує підключення додаткових бібіліотек. |
| `void` | Позначає відсутність типу. Використовується при оголошенні функцій. Змінну цього типу створити неможливо. | `void function() {}` | Вбудований тип. Не потребує підключення додаткових бібіліотек. |
| `std::string` | Текстовий рядок. | `std::string message = "Hello!";` | `#include <string>` |
| `std::vector<тип>` | Список елементів заданого типу. Тип задають всередині гострих дужок. Список може змінювати розмір, елементи можна додавати та видаляти зі списку. | `std::vector<std::string> friendList = {"Harry", "Ron", "Hermiona"};` | `#include <vector>` |
| `std::array<тип, розмір>` | Масив\(список фіксованого розміру\). Розмір масиву змінювати не можна. | `std::array<bool, 3> semaphorLightPowered = {false, false, true};` | `#include <array>` |

### Типи int та double.

Як ми знаємо, типи `int` та `double` використовують для збереження цілочислених та з плаваючою комою \(тих що мають дробову частину\) значень. Змінні типу `int` завичай можуть зберігати значення порядку +/-2,147,483,647. Але не обов'язково! **Зазвичай розмір значення яке може зберігатися у змінній цього типу може різнитися на різних комп'ютерах** \(в залежності від процесора, програмного оточення, тощо.\). Ми не будемо розглядати тут, чому це відбувається. **Головне запам'ятати, що кількість даних, які зберігаються у змінній типу **`int`** та **`double`** може різнитися на різних машинах.**

Тип `double` містить ще більше даних ніж тип `int`, для того, щоб мати можливість зберігати дробову частину числа з достатньою для більшості випадків точністю.

Дізнатися мінімальне та максимальне значення для вашого програмного оточення, які можуть зберігатися у змінній заданого типу, можна за допомогою `std::numeric_limits`. Приклад програми, яка виведе максимальне та мінімадбне значення, яке може зберігатися у змінній типу `int` наведено нижче:

```cpp
#include <iostream>
#include <numeric_limits>

int main()
{
    std::cout << "int max value is " << std::numeric_limits<int>::max
}
```

У прикладах в інтеренеті ви, можливо, побачите, що разом з назвою типів можуть також знаходитися модифікатори \(`short`, `long`, `unsigned` тощо\), які уточнюють розмір значень, що можуть бути збережені у змінну. Наразі, ми вчимося одновам - тож ви можете сміливо на початках використовувати просто тип `int`. Наразі для нас діє просте правило: **для цілих чисел використовуємо **`int`**, для цисел з плаваючою комою - **`double`.

Повну інформацію про ці та інші вбудовані типи, а також про розміри та модифікатори розміру тут: [http://en.cppreference.com/w/cpp/language/types](http://en.cppreference.com/w/cpp/language/types).

### Тип bool

Цей тип зберігає результат деякого твердження \(істинність чи хибність\). Наприклад:

```cpp
#include <iostream>

int main()
{
    std::cout << std::boolalpha; // Необхідно, щоб значення bool виводилися словами.
    bool isThreeIsGreaterThanFive{3 > 5};
    std::cout << "Is 3 > 5 : " << isThreeIsGreaterThanFive << std::endl;
    bool isThreeIsLessThanFive{3 < 5};
    std::cout << "Is 3 < 5 : " << isThreeIsLessThanFive << std::endl;
    bool isThreeEqualFive{3 == 5};
    std::cout << "Is 3 = 5 : " << isThreeEqualFive << std::endl;
    bool isThreeEqualThree{3 == 3};
    std::cout << "Is 3 = 3 : " << isThreeEqualThree << std::endl;
    bool isThreeNotEqualFive{3 != 5};
    std::cout << "Is 3 != 5 : " << isThreeNotEqualFive << std::endl;
}
```

Як ми бачимо, результатом порівняння \(оператори більше `>`, більше або дорівнює `>=`,  меньше`<`, меньше або дорівнює `<=`, дорівнює `==`, не рівно `!=`\) є значення типу `bool`.

Також до двох значень типу `bool` можна застосовувати оператори: заперечення `!` \(яке перетворює `true` у `false` та `false` у `true`\), логічне "АБО" `||` \(результатом якого є `true` якщо хоча б один з операндів містить `true`\), лоігчне "І" \(результатом якого є `true` якщо усі операнди містять `true`\).

### Тип char

| \# | chr | \# | chr | \# | chr | \# | chr | \# | chr | \# | chr | \# | chr |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 0 | NUL | 20 | DC4 | 40 | \( | 60 | &lt; | 80 | P | 100 | d | 0 | x |
| 1 | SOH | 21 | NAK | 41 | \) | 61 | = | 81 | Q | 101 | e | 1 | y |
| 2 | STX | 22 | SYN | 42 | \* | 62 | &gt; | 82 | R | 102 | f | 2 | z |
| 3 | ETX | 23 | ETB | 43 | + | 63 | ? | 83 | S | 103 | g | 3 | { |
| 4 | EOT | 24 | CAN | 44 |  | 64 | @ | 84 | T | 104 | h | 4 | \| |
| 5 | ENQ | 25 | EM | 45 | - | 65 | A | 85 | U | 105 | i | 5 | } |
| 6 | ASK | 26 | SUB | 46 | . | 66 | B | 86 | V | 106 | j | 6 | ~ |
| 7 | BEL | 27 | ESC | 47 | / | 67 | C | 87 | W | 107 | k | 7 | DEL |
| 8 | BS | 28 | FS | 48 | 0 | 68 | D | 88 | X | 108 | l |  |  |
| 9 | TAB | 29 | GS | 49 | 1 | 69 | E | 89 | Y | 109 | m |  |  |
| 10 | LF | 30 | RS | 50 | 2 | 70 | F | 90 | Z | 110 | n |  |  |
| 11 | VT | 31 | US | 51 | 3 | 71 | G | 91 | \[ | 111 | o |  |  |
| 12 | FF | 32 | '  ' | 52 | 4 | 72 | H | 92 | \ | 112 | p |  |  |
| 13 | CR | 33 | ! | 53 | 5 | 73 | I | 93 | \] | 113 | q |  |  |
| 14 | SO | 34 | " | 54 | 6 | 74 | J | 94 | ^ | 114 | r |  |  |
| 15 | SI | 35 | \# | 55 | 7 | 75 | K | 95 | \_ | 115 | s |  |  |
| 16 | DLE | 36 | $ | 56 | 8 | 76 | L | 96 | \` | 116 | t |  |  |
| 17 | DC1 | 37 | % | 57 | 9 | 77 | M | 97 | a | 117 | u |  |  |
| 18 | DC2 | 38 | & | 58 | : | 78 | N | 98 | b | 118 | v |  |  |
| 19 | DC3 | 39 | ' | 59 | ; | 79 | O | 99 | c | 119 | w |  |  |





| \# | chr | \# | chr | \# | chr | \# | chr | \# | chr | \# | chr | \# | chr | \# | chr |
| :--- | :---: | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 0 | `NUL` | 16 | `DLE` | 32 | ` ` | 48 | `0` | 64 | `@` | 80 | `P` | 96 | \`\` | 112 | `p` |
| 1 | `SOH` | 17 | `DC1` | 33 | `!` | 49 | `1` | 65 | `A` | 81 | `Q` | 97 | `a` | 113 | `q` |
| 2 | `STX` | 18 | `DC2` | 34 | `"` | 50 | `2` | 66 | `B` | 82 | `R` | 98 | `b` | 114 | `r` |
| 3 | `ETX` | 19 | `DC3` | 35 | `#` | 51 | `3` | 67 | `C` | 83 | `S` | 99 | `c` | 115 | `s` |
| 4 | `EOT` | 20 | `DC4` | 36 | `$` | 52 | `4` | 68 | `D` | 84 | `T` | 100 | `d` | 116 | `t` |
| 5 | `ENQ` | 21 | `NAK` | 37 | `%` | 53 | `5` | 69 | `E` | 85 | `U` | 101 | `e` | 117 | `u` |
| 6 | `ACK` | 22 | `SYN` | 38 | `&` | 54 | `6` | 70 | `F` | 86 | `V` | 102 | `f` | 118 | `v` |
| 7 | `BEL` | 23 | `ETB` | 39 | `'` | 55 | `7` | 71 | `G` | 87 | `W` | 103 | `g` | 119 | `w` |
| 8 | `BS` | 24 | `CAN` | 40 | `(` | 56 | `8` | 72 | `H` | 88 | `X` | 104 | `h` | 120 | `x` |
| 9 | `TAB` | 25 | `EM` | 41 | `)` | 57 | `9` | 73 | `I` | 89 | `Y` | 105 | `i` | 121 | `y` |
| 10 | `LF` | 26 | `SUB` | 42 | `*` | 58 | `:` | 74 | `J` | 90 | `Z` | 106 | `j` | 122 | `z` |
| 11 | `VT` | 27 | `ESC` | 43 | `+` | 59 | `;` | 75 | `K` | 91 | `[` | 107 | `k` | 123 | `{` |
| 12 | FF | 28 | FS | 44 | , | 60 | &lt; | 76 | L | 92 | \ | 108 | l | 124 | \` |
| 13 | `CR` | 29 | `GS` | 45 | `-` | 61 | `=` | 77 | `M` | 93 | `]` | 109 | `m` | 125 | `}` |
| 14 | `SO` | 30 | `RS` | 46 | `.` | 62 | `>` | 78 | `N` | 94 | `^` | 110 | `n` | 126 | `~` |
| 15 | `SI` | 31 | `US` | 47 | `/` | 63 | `?` | 79 | `O` | 95 | `_` | 111 | `o` | 127 | `DEL` |

### Неявне приведення вбудованих типів

### Тип std::string

### Тип std::vector

### Тип std::array



